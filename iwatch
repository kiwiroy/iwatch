#!/usr/bin/perl -T
# iWatch
# By Cahya Wirawan <cahya at gmx dot at>
# Usage in daemon mode: 
# iwatch [-f <configfile.xml>] [-d] [-v] [-p <pid file>]
# Usage in command line mode:
# iwatch [-c command] [-e event[,event[,..]]] [-m email] [-r] [-t filter] [-x exception] <target>
# iWatch monitor any changes in directories/files specified
# in the configuration file, and send email alert.
# This program needs inotify in linux kernel >= 2.6.13  

package iWatch::Utils;

use strict;
use warnings;
use Linux::Inotify2;

my $PROGRAM = "iWatch";
my $VERSION = "0.2.2";

our %InotifyEvents = (
    'access'        => IN_ACCESS,
    'modify'        => IN_MODIFY,
    'attrib'        => IN_ATTRIB,
    'close_write'   => IN_CLOSE_WRITE,
    'close_nowrite' => IN_CLOSE_NOWRITE,
    'open'          => IN_OPEN,
    'moved_from'    => IN_MOVED_FROM,
    'moved_to'      => IN_MOVED_TO,
    'create'        => IN_CREATE,
    'delete'        => IN_DELETE,
    'delete_self'   => IN_DELETE_SELF,
    'move_self'     => IN_MOVE_SELF,
    'unmount'       => IN_UNMOUNT,
    'q_overflow'    => IN_Q_OVERFLOW,
    'ignored'       => IN_IGNORED,
    'close'         => IN_CLOSE,
    'move'          => IN_MOVE,
    'isdir'         => IN_ISDIR,
    'oneshot'       => IN_ONESHOT,
    'all_events'    => IN_ALL_EVENTS,
    'default'       => IN_CLOSE_WRITE|IN_CREATE|IN_DELETE|IN_MOVE|IN_DELETE_SELF|IN_MOVE_SELF,
    );

my $formats = {
    'p' => sub { $PROGRAM },
    'v' => sub { $VERSION },
    'f' => sub { 
	my $event = shift;
	$event->{'Filename'} =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'" \\])/\\$1/g; 
	return $event->{'Filename'}; 
    },
    'F' => sub {
	my $event = shift;
	return '' if($event->{'Name'} !~ /MOVED_TO/ );
	$event->{'OldFilename'} =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'" \\])/\\$1/g;
	return $event->{'OldFilename'};
    },
    'e' => sub { my $event = shift; return $event->{'Name'};   },
    'c' => sub { my $event = shift; return $event->{'Cookie'}; },
    };

my $regexp_string  = join("|", map { "%".quotemeta } keys(%$formats));
my $formats_regexp = qr/$regexp_string/;

sub stringf($$) {
  my ($string, $event) = @_;
  $string =~ s/$formats_regexp/_stringf($&, $formats, $event)/ge;
  $string;
}
 
sub _stringf {
  my ($s, $f, $e) = @_;
  $s =~ s/^\%//;
  $f->{$s}->($e);
}

1;

package iWatch::Event;
use strict;
use warnings;

sub new       { bless { _c => $_[1] || {} }, $_[0]; }

sub filename      :lvalue { $_[0]->{'Filename'};    }
sub name          :lvalue { $_[0]->{'Name'};        }
sub cookie        :lvalue { $_[0]->{'Cookie'};      }
sub cookies       :lvalue { $_[0]->{'_c'};          }

sub handle_moved_from {
    my $self = shift;
    $self->cookies->{ $self->cookie } = $self->filename;
}
sub handle_moved_to {
    my $self = shift;
    $self->{'OldFilename'} = delete( $self->cookies->{ $self->cookie} );
    return $self->{'OldFilename'};
}

1;
package iWatch;

use strict;
use warnings;

sub new { 
    bless { 
	mail      => {}, 
	watchlist => {},
	event     => iWatch::Event->new() 
    }, $_[0];
}

sub charset   :lvalue { $_[0]->{'charset'};   }
sub mail      :lvalue { $_[0]->{'mail'};      }
sub watchlist :lvalue { $_[0]->{'watchlist'}; }
sub event     :lvalue { $_[0]->{'event'};     }
1;

package App::iWatch;

use strict;
use Getopt::Long;
use Event;
use Linux::Inotify2;
use File::Find;
use Mail::Sendmail;
use Sys::Hostname;
use XML::SimpleObject::LibXML;
use POSIX qw{:signal_h};
use Sys::Syslog;
use Sys::LoadAvg qw{loadavg};

my $VERBOSE      = 0;
my $CONFIGFILE_G = "/etc/iwatch.xml";
my $PIDFILE_G    = "/var/run/iwatch.pid";
my $CHARSET_G    = "utf-8";

my $CHILDREN_G = 0;
my %CHILDREN_G = ();

sub new {
    my $class = shift;
    my $self  = bless {
	configfile => $CONFIGFILE_G,
	pidfile    => $PIDFILE_G,
	charset    => $CHARSET_G,
	queue      => [],
	## these should be immutable
	inotify_event_names => {},
	iwatch              => iWatch->new(),
    }, ref($class) || $class;

    my $InotifyEventNames = $self->inotify_event_names;
    my %InotifyEvents     = $self->inotify_events;

    foreach my $EventName (keys %InotifyEvents) {
	$InotifyEventNames->{$InotifyEvents{$EventName}} = "IN_\U$EventName";
    }

    delete @ENV{qw(ENV IFS CDPATH)};
    $ENV{PATH} = "/bin:/usr/bin:/usr/sbin";

    return $self;
}

sub getopt_spec {
    my $self = shift;
    $self->{'events'} = [];
    $self->{'max'}    = 5;
    return (
	'help|h'       => sub { $self->usage(); },
	'config=s'     => \$self->{'configfile'},
	'command=s'    => \$self->{'command'},
	'charset=s'    => \$self->{'charset'},
	'daemon|d!'    => \$self->{'daemon'},
	'event|e=s'    => sub { push @{$self->{'events'}}, split(/,/, $_[1]); },
	'address|m=s'  => \$self->{'email_address'},
	'recurse|r'    => \$self->{'recursive'},
	'syslog|s!'    => \$self->{'syslog'},
	'filter|t=s'   => \$self->{'filter_str'},
	'verbose|v+'   => \$self->{'verbose'},
	'version'      => \$self->{'version'},
	'except|x=s'   => \$self->{'exception'},
	'reg-except=s' => \$self->{'exception_regexp'},
	'pidfile=s'    => \$self->{'pidfile'},
	'max=i'        => \$self->{'max'},
	);
}

sub max                         { $_[0]->{'max'};                 }
sub config_file                 { $_[0]->{'configfile'};          }
sub daemon                      { $_[0]->{'daemon'};              }
sub charset                     { $_[0]->{'charset'};             }
sub verbose                     { $_[0]->{'verbose'};             }
sub command             :lvalue { $_[0]->{'command'};             }
sub inotify             :lvalue { $_[0]->{'inotify'};             }
sub inotify_events              { %iWatch::Utils::InotifyEvents;  }
sub inotify_event_names :lvalue { $_[0]->{'inotify_event_names'}; }
sub iwatch                      { $_[0]->{'iwatch'};              }
sub queue               :lvalue { $_[0]->{'queue'};               }

sub pid_file { 
    my $p;
    ($p = $_[0]->{'pidfile'}) =~ /^(.+)$/; ## untaint
    return $p;  
}

sub daemonize {
    my $self = shift;
    my $ChildPid = fork;
    my $pidfile  = $self->pid_file;

    if($ChildPid) {
	open(FH, '>', "$pidfile") or die "Could not write to pidfile \"$pidfile\": $!";
	print FH "$ChildPid"; 
	close FH; 
    }
    
    die "Can't fork: $!\n" if(!defined $ChildPid);
    exit if($ChildPid);
    
    POSIX::setsid() or die "Can't start a new session: $!";
    open STDIN, "</dev/null";
    open STDOUT, ">/dev/null";
    open STDERR, ">&STDOUT";
    umask 0;
    chdir "/";
}

sub main {
    my $pkg  = shift;
    my $self = $pkg->new();
    my $xmlobj;

    my %options=();

    my $opt = GetOptions($self->getopt_spec);
    
    openlog("$PROGRAM", 'cons,pid', 'user');
   
    $VERBOSE += 2 if $self->verbose;
    
    ## FIX ME - Sanity check
    if((defined $options{d} || defined $options{f} || defined $options{p}) && 
       (-e $ARGV[0] || defined $options{c} || defined $options{C} || defined $options{e} || defined $options{m} 
	|| defined $options{r} || defined $options{s} || defined $options{t} || defined $options{w} || defined $options{x} | defined $options{X})) {
	print STDERR "Options [d|f|p] and [c|e|m|r|s|w|x] are mutually exlusive, you can't mix it!\n";
	$self->usage();
    }
    

    if(defined $options{w} || -e $ARGV[0]) {
	$VERBOSE  += 1;
	my $xmlstr = $self->generate_xml_string();
	$xmlobj    = XML::SimpleObject::LibXML->new (XML => "$xmlstr");
    }
    else {
	$xmlobj = $self->getXmlObject($self->config_file);
    }
    
    $self->daemonize() if $self->daemon;
    
    my $inotify = $self->inotify = Linux::Inotify2->new();

    Event->signal (signal => 'CHLD',
		   cb     => sub {
		       ## REAPER
		       my $sigset = POSIX::SigSet->new(&POSIX::SIGCHLD);
		       sigprocmask(SIG_BLOCK, $sigset)
			   or die "Can't block SIGCHLD for reaper: $!\n";
		       my $pid = wait;
		       if (delete $CHILDREN_G{$pid}) {
			   $CHILDREN_G--;
		       }
		       sigprocmask(SIG_UNBLOCK, $sigset);
		   });

    Event->signal (signal => 'INT',
		   cb     => sub {
		       ## HUNTSMAN
		       local ($SIG{CHLD}) = 'IGNORE';    # we're going to kill our children
		       kill 'INT' => keys %CHILDREN_G;
		       exit;                             # clean up with dignity
		   });
    
    Event->signal (signal => 'HUP', 
		   cb     => sub {
		       my $xmlobj = $self->getXmlObject($self->config_file);
		       while(my ($key, $watch) = each (%{$inotify->{'w'}}))
		       {
			   $watch->cancel;
		       }
		       $self->xmlDispatch($xmlobj);
		   })
	if(!(defined $options{w} || -e $ARGV[0]));
    
    $self->xmlDispatch($xmlobj);
    Event->io (fd => $inotify->fileno, poll => 'r', cb => sub { $inotify->poll });
    Event->timer(interval => 1, cb => sub { $self->_dispatch_queue(); });
    Event::loop;
}

sub _dispatch_queue {
    my $self  = shift;
    my $queue = $self->queue;
    my $MAX   = $self->max;
    my $last  = ($MAX > @$queue ? @$queue : $MAX);
    my $count = $CHILDREN_G;

    $self->message(0, '-', sprintf "timer went off - we have %d entries in queue", scalar(@$queue));
    
    for(my $i = $count; $i < $last; ++$i) {
	my $cmd = shift @$queue;
	$self->message(0, '_spawn_child', $cmd);
	_spawn_child( $cmd );
    }
}

sub getXmlObject {
  my ($self, $configFile) = @_;
  if(! -f $configFile) {
      $self->usage();
  }
  my $parser = XML::LibXML->new();
  open(CF, '<', $configFile);
  if(<CF> =~ /^<\?xml/) {
    $parser->validation(1);
  }
  else {
    print STDERR "Please use DTD for xml validation!\n";
    $parser->validation(0);
  }
  close(CF);
  my $xmlobj = XML::SimpleObject::LibXML ->new($parser->parse_file("$configFile"));
  return $xmlobj;
}

sub xmlDispatch {
    my $self     = shift;
    my ($xmlobj) = @_;
    my $iwatch   = $self->iwatch;
    my %WatchList;
    my %Mail;
    my %InotifyEvents = $self->inotify_events;

    $iwatch->charset = $xmlobj->child("config")->attribute("charset");
		my $inotify = $self->inotify;
  foreach my $watchlist ($xmlobj->child("config")->children("watchlist")) {
    foreach my $path ($watchlist->children("path")) {
      next if($path->attribute("type") ne "exception" &&
        $path->attribute("type") ne "regexception");
      if(-d $path->value) { $_ = $path->value; s/(.+)\/$/$1/; $path->value($_);}
      $WatchList{$path->attribute("type")}{$path->value}{"type"} = $path->attribute("type");
    }
  }

  foreach my $watchlist ($xmlobj->child("config")->children("watchlist")) {
    foreach my $path ($watchlist->children("path")) {
      next if($path->attribute("type") eq "exception" ||
        $path->attribute("type") eq "regexception");
      if(-d $path->value) { $_ = $path->value; s/(.+)\/$/$1/; $path->value($_);}
      $WatchList{$path->attribute("type")}{$path->value}{"contactpoint"} = 
        $watchlist->child("contactpoint")->attribute("email") if(defined($watchlist->child("contactpoint")));
      $WatchList{$path->attribute("type")}{$path->value}{"exec"} = $path->attribute("exec") if(defined($path->attribute("exec")));
      $WatchList{$path->attribute("type")}{$path->value}{"alert"} = 
        (defined($path->attribute("alert")) && $path->attribute("alert") eq "off") ? 0:1;
      $WatchList{$path->attribute("type")}{$path->value}{"type"} = $path->attribute("type");
      $WatchList{$path->attribute("type")}{$path->value}{"syslog"} =
        (defined($path->attribute("syslog")) && $path->attribute("syslog") eq "on") ? 1:0;
      $WatchList{$path->attribute("type")}{$path->value}{"filter"} = $path->attribute("filter");

      our $mask;
      $mask = (defined($path->attribute("events"))) ? $self->getMask($path->attribute("events"), \%InotifyEvents) : $InotifyEvents{'default'};
      $WatchList{$path->attribute("type")}{$path->value}{"mask"} = $mask;
      $mask |= $InotifyEvents{'create'} if($path->attribute("type") eq "recursive") . "\n";
      $self->pathwatch($path->attribute("type"), $path->value, %WatchList); 
    }
  }
    $Mail{From} = $xmlobj->child("config")->child("guard")->attribute("email");
    $Mail{'Content-Type'} = sprintf q{text/plain; charset=%s}, $iwatch->charset
	if(defined $iwatch->charset);
    $iwatch->mail = \%Mail;
    $iwatch->watchlist = \%WatchList;
    return $iwatch;  
}

sub getMask {
    my ($self, $events, $InotifyEvents) = @_;
    my $mask = 0;
    foreach my $event ( split(',', $events)) {
	$event =~ s/\s//g;
	warn "Event $event doesn't not exist!" if (!defined($InotifyEvents->{$event}));
	$mask = $mask | $InotifyEvents->{$event};
    }
    return $mask;
}

sub pathwatch {
    my $self = shift;
    our $mask;
    my $key;
    my ($mode, $path, %WatchList) = @_;
    my $inotify = $self->inotify;
    if(-e "$path") {
	return if(defined $WatchList{"exception"}{$path});
	foreach $key (keys %{$WatchList{"exception"}}) {
	    return undef if("$path" =~ /^$key/);
	}
	foreach $key (keys %{$WatchList{"regexception"}}) {
	    return if("$path" =~ /$key/);
	}
	if($mode eq "single") {
	    if($VERBOSE>1) {
		print "Watch $path\n";
		syslog("info","Watch $path");
	    }
	    print STDERR "Can't watch $path: $!\n"
		if(!$inotify->watch ("$path", $mask, sub { $self->mywatch( @_ ); }));
	} elsif($mode eq "recursive") {
	    #File::Find::find({wanted => \&wanted, "no_chdir" => 1}, "$path");
	    File::Find::find({wanted => sub{ $self->wanted(%WatchList);}, "no_chdir" => 1}, "$path");
	}
    }
    return ;
}

sub wanted {
    my $self = shift;
    our $mask;
    my $key;
    my (%WatchList) = @_;
    my $inotify = $self->inotify;
    if(-d $File::Find::name) {
	return if(defined $WatchList{"exception"}{$File::Find::name});
	foreach $key (keys %{$WatchList{"exception"}}) {
	    return undef if("$File::Find::name" =~ /^$key/);
	}
	foreach $key (keys %{$WatchList{"regexception"}}) {
	    return if("$File::Find::name" =~ /$key/);
	}
	#return if(!defined(getWatchList($File::Find::name)));
	if($VERBOSE>1) {
	    print "Watch $File::Find::name\n";
	    syslog("info","Watch $File::Find::name");
	}
	print STDERR "Can't watch $File::Find::name: $!\n"
	    if(!$inotify->watch ("$File::Find::name", $mask, sub { $self->mywatch(@_) }));
    }
}

sub getWatchList {
    my ($self, $path, $filename, $WatchList) = @_;
    my $rv;
    my $key;
    return undef if(defined $WatchList->{"exception"}{$path});
    foreach $key (keys %{$WatchList->{"exception"}}) {
	return undef if("$path" =~ /^$key/);
    }
    foreach $key (keys %{$WatchList->{"regexception"}}) {
	return undef if("$filename" =~ /$key/);
    }

    if(defined $WatchList->{"single"}{$path}) {
	$rv = $WatchList->{"single"}{$path};
    } elsif(defined $WatchList->{"recursive"}{$path}) {
	$rv = $WatchList->{"recursive"}{$path};
    } else {
	foreach $key (keys %{$WatchList->{"recursive"}}) {
	    if($path =~ /^$key/) {
		$rv = $WatchList->{"recursive"}{$key};
		last;
	    }
	}
    }
    (defined $rv->{"filter"} && "$filename" !~ /$rv->{'filter'}/) ?
	return undef                                              :
	return $rv ;
}

sub message {
    my $self  = shift;
    my $level = shift;
    printf STDERR "[%s] %s\n", @_[0..1] if $VERBOSE > $level;
}

sub mywatch {
    my ($self, $e) = @_;
    my $inotify = $self->inotify;
    my $iwatch  = $self->iwatch;
    my $Message;
    my $localMessage;
    my $mask;
    my %WatchList = %{ $iwatch->watchlist };
    my %Mail      = %{ $iwatch->mail };

    my $ievent   = $iwatch->event = 
	iWatch::Event->new($iwatch->event->cookies);

    my $Filename = $iwatch->event->filename = $e->fullname;

    return if(defined $WatchList{"exception"}{$Filename});
    my $Path = $self->getWatchList($e->{w}->{name}, $e->{name}, \%WatchList);
    return if(!defined($Path));
  
    my $now = POSIX::strftime "%e/%b/%Y %H:%M:%S", localtime;
    $ievent->name = "";
    $mask = $e->mask;
    if($e->IN_ISDIR) {
	$mask ^= IN_ISDIR;
	$ievent->name = "IN_ISDIR,";
    }
    if($e->IN_ONESHOT) {
	$mask ^= IN_ISDIR;
	$ievent->name = "IN_ONESHOT,";
    }

    $ievent->name  .= $self->inotify_event_names->{$mask};
    $ievent->cookie = $e->{cookie};

    $Message = sprintf q{%s %s}, $ievent->name, $Filename;
    $Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Message";
    if($VERBOSE>0 && $Path->{'mask'} & $mask) {
	$self->message(-1, $now, $Message);
	syslog("info","$Message") if($Path->{'syslog'});
    }
    if($e->IN_CREATE && -d $Filename && $Path->{'type'} eq "recursive") {
	$self->message(0, $now, "* Directory $Filename is watched");
	syslog("info","* Directory $Filename is watched") if($Path->{'syslog'});
	$self->message(-1, $now, "Can't watch $Filename: $!")
	    if(!$inotify->watch ($Filename, $Path->{'mask'} | $InotifyEvents{'create'}, sub { $self->mywatch(@_) }));
    }

    return if(!($Path->{'mask'} & $mask));

    if($e->IN_CLOSE_WRITE && -f $Filename) {
	$localMessage  = "* $Filename is closed";
	$Message       = join "\n", $Message, $localMessage;
	$Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is changed";  
	$self->message(0, $now, $localMessage);
	syslog("info","$localMessage") if($Path->{'syslog'});
    } elsif($e->IN_DELETE) {
	$localMessage = "* $Filename is deleted";
	$Message = "$Message\n$localMessage";
	$Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is deleted";  
	$self->message(0, $now, $localMessage);
	syslog("info","$localMessage") if($Path->{'syslog'});
    } elsif($e->IN_MOVED_FROM || $e->IN_MOVED_TO) {
	if($e->IN_MOVED_FROM) {
	    ## store the old filename
	    $ievent->handle_moved_from();
	} elsif($e->IN_MOVED_TO) {
	    $self->message(0, $now, sprintf "* cookie is %d", $e->{'cookie'});
	    my $old_filename = $ievent->handle_moved_to;
	    $localMessage  = sprintf(q{* %s is moved to %s},
				     $old_filename,
				     $Filename);
	    $Message       = "$Message\n$localMessage";
	    $Mail{Subject} = sprintf(q{[%s] %s: %s is moved to %s}, 
				     $PROGRAM, hostname(),
				     $old_filename,
				     $Filename);
	    $self->message(0, $now, $localMessage);
	    syslog("info","$localMessage") if($Path->{'syslog'});
	    if($e->IN_ISDIR) {
		our $mask;
		$mask = ($Path->{'type'} eq "recursive")? $Path->{'mask'} | $InotifyEvents{'create'} : $Path->{'mask'};
		$self->pathwatch($Path->{'type'}, $Filename, %WatchList);
	    }
	}
    } elsif($e->IN_DELETE_SELF && -f $Filename && defined $WatchList{$Filename}) {
	$localMessage = "* $Filename is replaced but watched again";
	$Message = "$Message\n$localMessage";
	$Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is replaced";  
	$self->message(0, $now, $localMessage);
	syslog("info","$localMessage") if($Path->{'syslog'});
	$inotify->watch ("$Filename", $Path->{'mask'}, sub { $self->mywatch(@_)});
    }
    $Path->{'exec'} = qq{echo [$now] p=\%p v=\%v ev=\%e file=\%f c=\%c old-file=\%F};
    if(defined($Path->{exec})) {
	my $command = iWatch::Utils::stringf("$Path->{exec}", $iwatch->event);
	$self->message(0, $now, "* Command: $command");
	syslog("info","* Command: $command") if($Path->{'syslog'});
	# We have already backslashed the escape characters in $Filename (in %formats).
	$command =~ /^(.+)$/;
	return if(!defined($1));
	my $securecommand = $1;
	#system("$securecommand");
	push @{ $self->queue }, $securecommand;
    }

    if(defined($Message) && $Path->{'alert'}) {
	$Mail{Message} = "[$now]\n$Message";
	$Mail{To} = $Path->{'contactpoint'};
	$self->message(0, $now, "* Send email to $Mail{To}");
	syslog("info","* Send email to $Mail{To}") if($Path->{'syslog'});
	sendmail(%Mail) or warn $Mail::Sendmail::error;
    }
}

sub generate_xml_string {
    my ($self) = @_;
    my %options;
    my $user = (getpwuid($>))[0];
    my @xmlstr;
    push @xmlstr, sprintf(q{<config charset="%s">}, $self->charset);
    push @xmlstr, sprintf(q{  <guard email="%s@localhost"/>}, $user);
    push @xmlstr, sprintf(q{  <watchlist>});
    push @xmlstr, sprintf(q{    <contactpoint email="%s"/>}, ((defined $options{m}) ? 
							      $options{m}           : 
							      "$user\@localhost"));
    push @xmlstr, sprintf(q{    <path });
    push @xmlstr, sprintf(q{       type="%s"}, ((defined $options{r}) ? "recursive" : "single"));
    push @xmlstr, sprintf(q{     events="%s"}, ((defined $options{e}) ? $options{e} : "default"));
    push @xmlstr, sprintf(q{       exec="%s"}, $options{c}) if (defined $options{c});
    push @xmlstr, sprintf(q{      alert="%s"}, ((defined $options{m}) ? "on" : "off"));
    push @xmlstr, sprintf(q{     syslog="%s"}, ((defined $options{s}) ? "on" : "off"));
    push @xmlstr, sprintf(q{     filter="%s"}, $options{t}) if (defined $options{t});
    push @xmlstr, sprintf(q{     >%s</path>}, ((-e $ARGV[0]) ? $ARGV[0] : $options{w}));
    push @xmlstr, sprintf(q{    <path type="exception">%s</path>}, $options{x})
	if(defined $options{x});
    push @xmlstr, sprintf(q{    <path type="regexception">%s</path>}, $options{X})
	if(defined $options{X});
    push @xmlstr, sprintf(q{  </watchlist>});
    push @xmlstr, sprintf(q{</config>});
    
    my $xmlstr = do { local $" = "\n"; "@xmlstr"; };
    print "XMLstr: \n$xmlstr\n" if $VERBOSE > 0;
    return $xmlstr;
}

sub _spawn_child {
    my $cmd = shift;
    my $pid;
    my $sigset  = POSIX::SigSet->new(&POSIX::SIGINT);
    $sigset->addset(&POSIX::SIGHUP);
    my $sigset2 = POSIX::SigSet->new(&POSIX::SIGHUP);

    # block 'INT' signal during fork
    sigprocmask(SIG_BLOCK, $sigset) or die "Can't block SIGINT for fork: $!\n";
    die "fork failed: $!" unless defined($pid = fork);
    sigprocmask(SIG_UNBLOCK, $sigset)
	or die "Can't unblock SIGINT for fork: $!\n";

    if ($pid) {
###########################################################################################
        # Parent process code executes from here
        # Parent records the child's birth and returns.
###########################################################################################
        $CHILDREN_G{$pid} = 1;
        $CHILDREN_G++;

        return;
    } else {
###########################################################################################
        # Child process code executes from here
###########################################################################################

        $SIG{INT} = 'DEFAULT';
        $SIG{HUP} =
	    sub { print STDERR "Received SIGHUP, child $$ resigning\n"; exit; };

	sigprocmask(SIG_BLOCK, $sigset2)
	    or die "Can't block SIGHUP for request: $!\n";
	my $sigset_CHLD = POSIX::SigSet->new(&POSIX::SIGCHLD);
	sigprocmask(SIG_BLOCK, $sigset_CHLD)
	    or die "Can't block SIGCHLD for THIS BIT: $!\n";

	open(my $fh, '-|', $cmd);
	while (<$fh>) {
	    chomp;
	    warn "[result] $_\n";
	}
	close $fh;

	sigprocmask(SIG_UNBLOCK, $sigset_CHLD)
	    or die "Can't unblock SIGCHLD after request: $!\n";
	#      $SIG{CHLD} = \&REAPER;
	sigprocmask(SIG_UNBLOCK, $sigset2)
	    or die "Can't unblock SIGHUP after request: $!\n";

	exit 0;
    }
###########################################################################################
    ## End of _spawn_child
###########################################################################################
}

sub usage {
  VERSION_MESSAGE();
  HELP_MESSAGE();
  exit 0;
}

sub VERSION_MESSAGE {
  print "$PROGRAM $VERSION, a realtime filesystem monitor.\n";
  print "Cahya Wirawan <cahya at gmx dot at>, Vienna 2006.\n";
}

sub HELP_MESSAGE {
  print <<ENDOFHELP;
  
In the daemon mode, $PROGRAM has following options:
Usage: iwatch [-d] [-f <config file>] [-v] [-p <pid file>]
  -d Execute the application as daemon.
  -f <config file>
     Specify an alternate xml configuration file.
  -p <pid file>
     Specify an alternate pid file (default: $PIDFILE_G)
  -v Verbose mode.

And in the command line mode:
Usage: iwatch [-c command] [-C charset] [-e event[,event[,..]]] [-h|--help] [-m <email address>] 
         [-r] [-s <on|off>] [-t <filter string>] [-v] [--version] [-x exception]
         [-X <regex string as exception>] <target>

  Target is the directory or file you want to monitor.
  -c command
     Specify a command to be executed if an event occurs. And you can use
     following special string format in the command:
       %c Event cookie number
       %e Event name
       %f Full path of the filename that gets an event.
       %F The old filename in case moved_to event.
       %p Program name (iWatch)
       %v Version number
  -C charset
     Specify the charset (default is utf-8)
  -e event[,event[,..]]
     Specify a list of events you want to watch. Following are the possible events you can use:
       access        : file was accessed
       modify        : file was modified
       attrib        : file attributes changed
       close_write   : file closed, after being opened in writeable mode
       close_nowrite : file closed, after being opened in read-only mode
       close         : file closed, regardless of read/write mode
       open          : file was opened
       moved_from    : File was moved away from.
       moved_to      : File was moved to.
       move          : a file/dir within watched directory was moved
       create        : a file was created within watched directory
       delete        : a file was deleted within watched directory
       delete_self   : the watched file was deleted
       unmount       : file system on which watched file exists was unmounted
       q_overflow    : Event queued overflowed
       ignored       : File was ignored
       isdir         : event occurred against dir
       oneshot       : only send event once
       all_events    : All events
       default       : close_write, create, delete, move, delete_self and move_self.
  -h, --help
     Print this help.
  -m <email address>
     Specify the contact point's email address.
  -r Recursivity of the watched directory.
  -s <on|off>
     Enable or disable reports to the syslog (default is off/disabled)
  -t <filter string>
     Specify a filter string (regex) to compare with the filename or directory name. 
  -v verbose mode.
  --version
     Print the version number.
  -x exception
     Specify the file or directory which should not be watched.
  -X <regex string as exception>
     Specify a regex string as exception
ENDOFHELP
}

exit ( __PACKAGE__->main( @ARGV ) ) unless caller();
