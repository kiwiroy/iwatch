#!/usr/bin/perl -T
# iWatch
# By Cahya Wirawan <cahya at gmx dot at>
# Usage in daemon mode: 
# iwatch [-f <configfile.xml>] [-d] [-v] [-p <pid file>]
# Usage in command line mode:
# iwatch [-c command] [-e event[,event[,..]]] [-m email] [-r] [-t filter] [-x exception] <target>
# iWatch monitor any changes in directories/files specified
# in the configuration file, and send email alert.
# This program needs inotify in linux kernel >= 2.6.13  
package iWatch;

use strict;
use warnings;

my $PROGRAM = "iWatch";
my $VERSION = "0.2.2";

my $VERBOSE      = 0;
my $CONFIGFILE_G = "/etc/iwatch.xml";
my $PIDFILE_G    = "/var/run/iwatch.pid";
my $CHARSET_G    = "utf-8";

my $CHILDREN_G = 0;
my %CHILDREN_G = ();

sub new { 
    bless { 
	mail      => {}, 
	watchlist => {},
	event     => iWatch::Event->new() 
    }, $_[0];
}

sub charset   :lvalue { $_[0]->{'charset'};   }
sub mail      :lvalue { $_[0]->{'mail'};      }
sub watchlist :lvalue { $_[0]->{'watchlist'}; }
sub event     :lvalue { $_[0]->{'event'};     }

1;

package iWatch::Event;
use strict;
use warnings;
use POSIX qw{strftime};
{
    my $formats = {
	'p' => sub { $PROGRAM },
	'v' => sub { $VERSION },
	'f' => sub { _filename( @_ )      },
	'F' => sub { _old_filename( @_ ); },
	'e' => sub { name( @_ );      },
	'c' => sub { cookie( @_ );    },
    };
    my $regexp_string  = join("|", map { "%".quotemeta } keys(%$formats));
    my $formats_regexp = qr/$regexp_string/;
    sub _formats_regexp { return $formats_regexp; }
    sub _function_table { return $formats;        }
}
sub new { 
    my $class   = shift;
    my $cookies = shift;
    my $self    = bless { 
	_c     => $cookies || {}, 
	name   => '',
	now    => strftime( "%e/%b/%Y %H:%M:%S", localtime ),
    }, $class;
    return $self;
}

sub filename      :lvalue { $_[0]->{'filename'};    }
sub name          :lvalue { $_[0]->{'name'};        }
sub cookie        :lvalue { $_[0]->{'cookie'};      }
sub cookies       :lvalue { $_[0]->{'_c'};          }
sub old_filename          { $_[0]->{'oldfilename'}; }
sub now                   { $_[0]->{'now'};         }
sub handle_moved_from {
    my $self = shift;
    $self->cookies->{ $self->cookie } = $self->filename;
}
sub handle_moved_to {
    my $self = shift;
    $self->{'oldfilename'} = delete( $self->cookies->{ $self->cookie} );
    return $self->{'oldfilename'};
}

sub _old_filename {
    my $self   = shift;
    my $retval = '';
    return $retval if($self->name !~ /MOVED_TO/ );
    ($retval = $self->old_filename) =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'" \\])/\\$1/g;
    return $retval;
}
sub _filename {
    my $self = shift;
    my $retval; ($retval = $self->filename) 
	=~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'" \\])/\\$1/g; 
    return $retval;
}

sub apply_to_command {
  my ($self, $command) = @_;
  my $regexp = $self->_formats_regexp;
  my $format = $self->_function_table;
  $command   =~ s/$regexp/_stringf($&, $format, $self)/ge;
  return $command;
}
 
sub _stringf {
  my ($s, $f, $e) = @_;
  $s =~ s/^\%//;
  $f->{$s}->($e);
}

1;

package App::iWatch;

use strict;
use warnings;

use POSIX qw{:signal_h};
use Event;
use File::Find;
use Getopt::Long qw{GetOptions :config no_ignore_case};

use Linux::Inotify2;
use Mail::Sendmail;
use XML::SimpleObject::LibXML;
use Sys::Hostname;
use Sys::Syslog;
use Sys::LoadAvg qw{loadavg LOADAVG_1MIN LOADAVG_5MIN LOADAVG_15MIN};

sub new {
    my $class = shift;
    my $self  = bless {
	configfile => $CONFIGFILE_G,
	pidfile    => $PIDFILE_G,
	charset    => $CHARSET_G,
	queue      => [],
	## these should be immutable
	inotify_event_names => {},
	iwatch              => iWatch->new(),
    }, ref($class) || $class;

    my %InotifyEvents = (
	'access'        => IN_ACCESS,
	'modify'        => IN_MODIFY,
	'attrib'        => IN_ATTRIB,
	'close_write'   => IN_CLOSE_WRITE,
	'close_nowrite' => IN_CLOSE_NOWRITE,
	'open'          => IN_OPEN,
	'moved_from'    => IN_MOVED_FROM,
	'moved_to'      => IN_MOVED_TO,
	'create'        => IN_CREATE,
	'delete'        => IN_DELETE,
	'delete_self'   => IN_DELETE_SELF,
	'move_self'     => IN_MOVE_SELF,
	'unmount'       => IN_UNMOUNT,
	'q_overflow'    => IN_Q_OVERFLOW,
	'ignored'       => IN_IGNORED,
	'close'         => IN_CLOSE,
	'move'          => IN_MOVE,
	'isdir'         => IN_ISDIR,
	'oneshot'       => IN_ONESHOT,
	'all_events'    => IN_ALL_EVENTS,
	'default'       => IN_CLOSE_WRITE|IN_CREATE|IN_DELETE|IN_MOVE|IN_DELETE_SELF|IN_MOVE_SELF,
	);

    my $InotifyEventNames = $self->inotify_event_names;
    $self->inotify_events = \%InotifyEvents;

    foreach my $EventName (keys %InotifyEvents) {
	$InotifyEventNames->{$InotifyEvents{$EventName}} = "IN_\U$EventName";
    }

    $self->update_load;

    delete @ENV{qw(ENV IFS CDPATH)};
    $ENV{PATH} = "/bin:/usr/bin:/usr/sbin";

    return $self;
}

sub getopt_spec {
    my $self = shift;

    $self->{'events'}      = [];
    $self->{'max_child'}   = 5;
    $self->{'max_load'}    = 20;
    $self->{'load_metric'} = LOADAVG_1MIN;
    $self->{'recursive'}   = 0;
    $self->{'alert'}       = 0;
    $self->{'use_syslog'}  = 0;
    $self->{'user'}        = (getpwuid($>))[0];
    $self->{'email_address'} =
	join '@', $self->{'user'}, 'localhost';

    return (
	'help|h'         => $self->usage,
	'config|f=s'     => \$self->{'configfile'},
	'watch|w=s'      => \$self->{'watch_path'},
	'command|c=s'    => \$self->{'command'},
	'charset=s'      => \$self->{'charset'},
	'daemon|d!'      => \$self->{'daemon'},
	'event|e=s'      => sub { push @{$self->{'events'}}, split(/,/, $_[1]); },
	'address|m=s'    => sub { $self->{'email_address'} = $_[1]; $self->{'alert'} = 1; },
	'recurse|r'      => \$self->{'recursive'},
	'syslog|s!'      => \$self->{'syslog'},
	'filter|t=s'     => \$self->{'filter_str'},
	'verbose|v+'     => \$self->{'verbose'},
	'version'        => $self->script_version,
	'except|x=s'     => \$self->{'exception'},
	'reg-except|X=s' => \$self->{'exception_regexp'},
	'pidfile=s'      => \$self->{'pidfile'},
	'max-child=i'    => \$self->{'max_child'},
	'max-load=i'     => \$self->{'max_load'},
	'1'              => sub { $self->{'load_metric'} = LOADAVG_1MIN;  },
	'5'              => sub { $self->{'load_metric'} = LOADAVG_5MIN;  },
	'15'             => sub { $self->{'load_metric'} = LOADAVG_15MIN; },
	);
}

sub queue               :lvalue { $_[0]->{'queue'};               }
sub inotify             :lvalue { $_[0]->{'inotify'};             }
sub inotify_events      :lvalue { $_[0]->{'inotify_events'};      }
sub inotify_event_names         { $_[0]->{'inotify_event_names'}; }
sub iwatch                      { $_[0]->{'iwatch'};              }
sub load_avg                    { $_[0]->{'load_avg'};            }

sub max_children                { $_[0]->{'max_child'};           }
sub max_load                    { $_[0]->{'max_load'};            }
sub config_file                 { $_[0]->{'configfile'};          }
sub daemon                      { $_[0]->{'daemon'};              }
sub charset                     { $_[0]->{'charset'};             }
sub verbose                     { $_[0]->{'verbose'};             }
sub command                     { $_[0]->{'command'};             }
sub email                       { $_[0]->{'email_address'};       }
sub recursive                   { $_[0]->{'recursive'};           }
sub watch_events                { $_[0]->{'events'};              }
sub filter_string               { $_[0]->{'filter_str'};          }
sub email_alert                 { $_[0]->{'alert'};               }
sub use_syslog                  { $_[0]->{'syslog'};              }
sub exception                   { $_[0]->{'exception'};           }
sub exception_regexp            { $_[0]->{'exception_regexp'};    }

sub watch_path {
    my ($self) = @_;
    my ($path) = grep { defined($_) && -e $_ } $self->{'watch_path'}, @ARGV;
    return $path;
}

sub update_load {
    my $self = shift;
    $self->{'load_avg'} = [ loadavg() ];
}

sub pid_file { 
    my $p;
    ($p = $_[0]->{'pidfile'}) =~ /^(.+)$/; ## untaint
    return $p;  
}

sub daemonize {
    my $self     = shift;
    my $pidfile  = $self->pid_file;
    my $ChildPid = fork; ## fork 
    if($ChildPid) {
	open(FH, '>', "$pidfile") or die "Could not write to pidfile \"$pidfile\": $!";
	print FH "$ChildPid"; 
	close FH; 
    }
    
    die "Can't fork: $!\n" if(!defined $ChildPid);
    exit if($ChildPid);
    
    POSIX::setsid() or die "Can't start a new session: $!";
    open STDIN, "</dev/null";
    open STDOUT, ">/dev/null";
    open STDERR, ">&STDOUT";
    umask 0;
    chdir "/";
}

sub main {
    my $pkg  = shift;
    my $self = $pkg->new();
    my $xmlobj;

    my %options=();

    my $opt = GetOptions($self->getopt_spec);
    
    openlog("$PROGRAM", 'cons,pid', 'user');
   
    $VERBOSE += 2 if $self->verbose;
    
    ## FIX ME - Sanity check
    if((defined $options{d} || defined $options{f} || defined $options{p}) && 
       (-e $ARGV[0] || defined $options{c} || defined $options{C} || defined $options{e} || defined $options{m} 
	|| defined $options{r} || defined $options{s} || defined $options{t} || defined $options{w} || defined $options{x} | defined $options{X})) {
	print STDERR "Options [d|f|p] and [c|e|m|r|s|w|x] are mutually exlusive, you can't mix it!\n";
	$self->usage->();
    }
    

    if($self->watch_path) {
	$VERBOSE  += 1;
	my $xmlstr = $self->generate_xml_string();
	$xmlobj    = XML::SimpleObject::LibXML->new (XML => "$xmlstr");
    } else {
	$xmlobj = $self->getXmlObject($self->config_file);
    }
    
    $self->daemonize() if $self->daemon;

    my $inotify = $self->inotify = Linux::Inotify2->new();

    Event->signal (signal => 'CHLD',
		   cb     => sub {
		       my $event = shift;
		       ## REAPER
		       for(my $i = 0; $i < $event->hits; ++$i) {
			#   my $sigset = POSIX::SigSet->new(&POSIX::SIGCHLD);
			#   sigprocmask(SIG_BLOCK, $sigset)
			#       or die "Can't block SIGCHLD for reaper: $!\n";
			   my $pid = wait;
			   if (delete $CHILDREN_G{$pid}) {
			       warn "$pid removed\n";
			       $CHILDREN_G--;
			   }
			#   sigprocmask(SIG_UNBLOCK, $sigset);
		       }
		   });

    Event->signal (signal => 'INT',
		   cb     => sub {
		       ## HUNTSMAN
		       local ($SIG{CHLD}) = 'IGNORE';    # we're going to kill our children
		       kill 'INT' => keys %CHILDREN_G;
		       exit;                             # clean up with dignity
		   });
    
    Event->signal (signal => 'HUP', 
		   cb     => sub {
		       ## RE-CONFIGURE
		       my $xmlobj = $self->getXmlObject($self->config_file);
		       while(my ($key, $watch) = each (%{$inotify->{'w'}}))
		       {
			   $watch->cancel;
		       }
		       $self->xmlDispatch($xmlobj);
		   })
	if(!($self->watch_path));

    my $itrn = 0;
    $self->xmlDispatch($xmlobj);
    Event->io (fd => $inotify->fileno, poll => 'r', cb => sub { $inotify->poll });
    Event->timer(interval => 1, cb => sub { $self->_dispatch_queue(++$itrn);   }); 
    Event::loop;

    return 0; ## time to exit
}

sub _dispatch_queue {
    my $self  = shift;
    my $itrn  = shift;
    my $queue = $self->queue;
    my $MAX   = $self->max_children;
    my $last  = ($MAX > @$queue ? @$queue : $MAX);
    my $count = ($CHILDREN_G ? $CHILDREN_G - 1 : $CHILDREN_G);

    my $load     = $self->load_avg->[ $self->{'load_metric'} ];
    my $max_load = $self->max_load;

    $self->message(0, '-', sprintf("we have %d entries in queue and %d children last=%d, load=%.2f",
				   scalar(@$queue), $CHILDREN_G, $last, $load));

    for(my $i = $count; $load < $max_load && $i < $last; ++$i) {
	my $cmd = shift @$queue;
	$self->message(0, '_spawn_child', $cmd);
	_spawn_child( $cmd );
    }

    kill 'CHLD', $$ unless $itrn % 40; ## holes in the block logic / signal impl.

    $self->update_load unless $itrn % 120; ## 2 minutes ~ish
}

sub getXmlObject {
  my ($self, $configFile) = @_;
  if(! -f $configFile) {
      $self->usage->();
  }
  my $parser = XML::LibXML->new();
  open(CF, '<', $configFile);
  if(<CF> =~ /^<\?xml/) {
    $parser->validation(1);
  }
  else {
    print STDERR "Please use DTD for xml validation!\n";
    $parser->validation(0);
  }
  close(CF);
  my $xmlobj = XML::SimpleObject::LibXML ->new($parser->parse_file("$configFile"));
  return $xmlobj;
}

sub xmlDispatch {
    my $self     = shift;
    my ($xmlobj) = @_;
    my $iwatch   = $self->iwatch;
    my %WatchList;
    my %Mail;
    my %InotifyEvents = %{ $self->inotify_events };

    $iwatch->charset = $xmlobj->child("config")->attribute("charset");
		my $inotify = $self->inotify;
  foreach my $watchlist ($xmlobj->child("config")->children("watchlist")) {
    foreach my $path ($watchlist->children("path")) {
      next if($path->attribute("type") ne "exception" &&
        $path->attribute("type") ne "regexception");
      if(-d $path->value) { $_ = $path->value; s/(.+)\/$/$1/; $path->value($_);}
      $WatchList{$path->attribute("type")}{$path->value}{"type"} = $path->attribute("type");
    }
  }

  foreach my $watchlist ($xmlobj->child("config")->children("watchlist")) {
    foreach my $path ($watchlist->children("path")) {
      next if($path->attribute("type") eq "exception" ||
        $path->attribute("type") eq "regexception");
      if(-d $path->value) { $_ = $path->value; s/(.+)\/$/$1/; $path->value($_);}
      $WatchList{$path->attribute("type")}{$path->value}{"contactpoint"} = 
        $watchlist->child("contactpoint")->attribute("email") if(defined($watchlist->child("contactpoint")));
      $WatchList{$path->attribute("type")}{$path->value}{"exec"} = $path->attribute("exec") if(defined($path->attribute("exec")));
      $WatchList{$path->attribute("type")}{$path->value}{"alert"} = 
        (defined($path->attribute("alert")) && $path->attribute("alert") eq "off") ? 0:1;
      $WatchList{$path->attribute("type")}{$path->value}{"type"} = $path->attribute("type");
      $WatchList{$path->attribute("type")}{$path->value}{"syslog"} =
        (defined($path->attribute("syslog")) && $path->attribute("syslog") eq "on") ? 1:0;
      $WatchList{$path->attribute("type")}{$path->value}{"filter"} = $path->attribute("filter");

      our $mask;
      $mask = (defined($path->attribute("events"))) ? $self->getMask($path->attribute("events"), \%InotifyEvents) : $InotifyEvents{'default'};
      $WatchList{$path->attribute("type")}{$path->value}{"mask"} = $mask;
      $mask |= $InotifyEvents{'create'} if($path->attribute("type") eq "recursive") . "\n";
      $self->pathwatch($path->attribute("type"), $path->value, %WatchList); 
    }
  }
    $Mail{From} = $xmlobj->child("config")->child("guard")->attribute("email");
    $Mail{'Content-Type'} = sprintf q{text/plain; charset=%s}, $iwatch->charset
	if(defined $iwatch->charset);
    $iwatch->mail = \%Mail;
    $iwatch->watchlist = \%WatchList;
    return $iwatch;  
}

sub getMask {
    my ($self, $events, $InotifyEvents) = @_;
    my $mask = 0;
    foreach my $event ( split(',', $events)) {
	$event =~ s/\s//g;
	warn "Event $event doesn't not exist!" if (!defined($InotifyEvents->{$event}));
	$mask = $mask | $InotifyEvents->{$event};
    }
    return $mask;
}

sub pathwatch {
    my $self = shift;
    our $mask;
    my $key;
    my ($mode, $path, %WatchList) = @_;
    my $inotify = $self->inotify;
    if(-e "$path") {
	return if(defined $WatchList{"exception"}{$path});
	foreach $key (keys %{$WatchList{"exception"}}) {
	    return undef if("$path" =~ /^$key/);
	}
	foreach $key (keys %{$WatchList{"regexception"}}) {
	    return if("$path" =~ /$key/);
	}
	if($mode eq "single") {
	    if($VERBOSE>1) {
		print "Watch $path\n";
		syslog("info","Watch $path");
	    }
	    print STDERR "Can't watch $path: $!\n"
		if(!$inotify->watch ("$path", $mask, sub { $self->mywatch( @_ ); }));
	} elsif($mode eq "recursive") {
	    #File::Find::find({wanted => \&wanted, "no_chdir" => 1}, "$path");
	    File::Find::find({wanted => sub{ $self->wanted(%WatchList);}, "no_chdir" => 1}, "$path");
	}
    }
    return ;
}

sub wanted {
    my $self = shift;
    our $mask;
    my $key;
    my (%WatchList) = @_;
    my $inotify = $self->inotify;
    if(-d $File::Find::name) {
	return if(defined $WatchList{"exception"}{$File::Find::name});
	foreach $key (keys %{$WatchList{"exception"}}) {
	    return undef if("$File::Find::name" =~ /^$key/);
	}
	foreach $key (keys %{$WatchList{"regexception"}}) {
	    return if("$File::Find::name" =~ /$key/);
	}
	#return if(!defined(getWatchList($File::Find::name)));
	if($VERBOSE>1) {
	    print "Watch $File::Find::name\n";
	    syslog("info","Watch $File::Find::name");
	}
	print STDERR "Can't watch $File::Find::name: $!\n"
	    if(!$inotify->watch ("$File::Find::name", $mask, sub { $self->mywatch(@_) }));
    }
}

sub getWatchList {
    my ($self, $path, $filename, $WatchList) = @_;
    my $rv;
    my $key;
    return undef if(defined $WatchList->{"exception"}{$path});
    foreach $key (keys %{$WatchList->{"exception"}}) {
	return undef if("$path" =~ /^$key/);
    }
    foreach $key (keys %{$WatchList->{"regexception"}}) {
	return undef if("$filename" =~ /$key/);
    }

    if(defined $WatchList->{"single"}{$path}) {
	$rv = $WatchList->{"single"}{$path};
    } elsif(defined $WatchList->{"recursive"}{$path}) {
	$rv = $WatchList->{"recursive"}{$path};
    } else {
	foreach $key (keys %{$WatchList->{"recursive"}}) {
	    if($path =~ /^$key/) {
		$rv = $WatchList->{"recursive"}{$key};
		last;
	    }
	}
    }
    (defined $rv->{"filter"} && "$filename" !~ /$rv->{'filter'}/) ?
	return undef                                              :
	return $rv ;
}

sub message {
    my $self  = shift;
    my $level = shift;
    printf STDERR "[%s] %s\n", @_[0..1] if $VERBOSE > $level;
}

sub mywatch {
    my ($self, $e) = @_;
    my ($syslog_message, $mail_subject, $mask);
    my $inotify       = $self->inotify;
    my $iwatch        = $self->iwatch;
    my %WatchList     = %{ $iwatch->watchlist };
    my %Mail          = %{ $iwatch->mail };
    my %InotifyEvents = %{ $self->inotify_events };
    my $ievent        = $iwatch->event = 
	iWatch::Event->new($iwatch->event->cookies);
    my $filename      = $iwatch->event->filename =
	$e->fullname;

    return if(defined $WatchList{"exception"}{$filename});
    my $Path = $self->getWatchList($e->{w}->{name}, $e->{name}, \%WatchList);
    return if(!defined($Path));
  
    $mask = $e->mask;
    if($e->IN_ISDIR) {
	$mask ^= IN_ISDIR;
	$ievent->name = "IN_ISDIR,";
    }
    if($e->IN_ONESHOT) {
	$mask ^= IN_ISDIR;
	$ievent->name = "IN_ONESHOT,";
    }

    $ievent->name  .= $self->inotify_event_names->{$mask};
    $ievent->cookie = $e->{cookie};

    if($VERBOSE>0 && $Path->{'mask'} & $mask) {
	my $message = sprintf q{%s %s}, $ievent->name, $filename;
	$self->message(-1, $ievent->now, $message);
	syslog("info", $message) if($Path->{'syslog'});
    }
    if($e->IN_CREATE && -d $filename && $Path->{'type'} eq "recursive") {
	$self->message(0, $ievent->now, "* Directory $filename is watched");
	syslog("info","* Directory $filename is watched") if($Path->{'syslog'});
	$self->message(-1, $ievent->now, "Can't watch $filename: $!")
	    if(!$inotify->watch ($filename, $Path->{'mask'} | $InotifyEvents{'create'}, sub { $self->mywatch(@_) }));
    }

    return if(!($Path->{'mask'} & $mask));

    my $filename_is  = sub { return "$filename is @_"; };

    if($e->IN_CLOSE_WRITE && -f $filename) {
	$mail_subject   = $filename_is->("changed");  
	$syslog_message = "* $mail_subject";
	$self->message(0, $ievent->now, $syslog_message);
	syslog("info","$syslog_message") if($Path->{'syslog'});
    } elsif($e->IN_DELETE) {
	$mail_subject   = $filename_is ->("deleted");
	$syslog_message = "* $mail_subject";
	$self->message(0, $ievent->now, $syslog_message);
	syslog("info","$syslog_message") if($Path->{'syslog'});
    } elsif($e->IN_MOVED_FROM || $e->IN_MOVED_TO) {
	if($e->IN_MOVED_FROM) {
	    ## store the old filename
	    $ievent->cookie = $e->{'cookie'};
	    $ievent->handle_moved_from();
	} elsif($e->IN_MOVED_TO) {
	    $self->message(0, $ievent->now, sprintf "* cookie is %d", $e->{'cookie'});
	    my $old_filename = $ievent->handle_moved_to;
	    $mail_subject    = sprintf(q{%s is moved to %s}, $old_filename, $filename);
	    $syslog_message  = "* $mail_subject";
	    $self->message(0, $ievent->now, $syslog_message);
	    syslog("info","$syslog_message") if($Path->{'syslog'});
	    if($e->IN_ISDIR) {
		our $mask;
		$mask = ($Path->{'type'} eq "recursive")? $Path->{'mask'} | $InotifyEvents{'create'} : $Path->{'mask'};
		$self->pathwatch($Path->{'type'}, $filename, %WatchList);
	    }
	}
    } elsif($e->IN_DELETE_SELF && -f $filename && defined $WatchList{$filename}) {
	$mail_subject   = $filename_is->("replaced");  
	$syslog_message = "* $mail_subject but watched again";
	$self->message(0, $ievent->now, $syslog_message);
	syslog("info", $syslog_message) if($Path->{'syslog'});
	$inotify->watch ("$filename", $Path->{'mask'}, sub { $self->mywatch(@_); });
    }

    if(defined($Path->{exec})) {
	my $command = $ievent->apply_to_command($Path->{exec});
	$self->message(0, $ievent->now, "* Command: $command");
	syslog("info","* Command: $command") if($Path->{'syslog'});
	# We have already backslashed the escape characters in $filename (in %formats).
	$command =~ /^(.+)$/;
	return if(!defined($1));
	my $securecommand = $1;
	push @{ $self->queue }, $securecommand;
    }

    if($Path->{'alert'}) {
	$Mail{Message} = sprintf(qq{[%s] %s %s\n%s}, 
				 $ievent->now, $ievent->name, $filename, $syslog_message);
	$Mail{To}      = $Path->{'contactpoint'};
	$Mail{Subject} = sprintf(q{[%s] %s: %s}, $PROGRAM, hostname(), $mail_subject);
	$self->message(0, $ievent->now, "* Send email to $Mail{To}");
	syslog("info","* Send email to $Mail{To}") if($Path->{'syslog'});
	sendmail(%Mail) or warn $Mail::Sendmail::error;
    }
}

sub generate_xml_string {
    my ($self) = @_;
    my @xmlstr;
    push @xmlstr, sprintf(q{<config charset="%s">}, $self->charset);
    push @xmlstr, sprintf(q{  <guard email="%s@localhost"/>}, $self->{'user'});
    push @xmlstr, sprintf(q{  <watchlist>});
    push @xmlstr, sprintf(q{    <contactpoint email="%s"/>}, $self->email);
    push @xmlstr, sprintf(q{    <path });
    push @xmlstr, sprintf(q{       type="%s"}, ($self->recursive ? "recursive" : "single"));
    push @xmlstr, sprintf(q{     events="%s"}, 
			  (@{$self->watch_events} ? join(',', @{$self->watch_events}) : "default"));
    push @xmlstr, sprintf(q{       exec="%s"}, $self->command) if (defined $self->command);
    push @xmlstr, sprintf(q{      alert="%s"}, ($self->email_alert ? "on" : "off"));
    push @xmlstr, sprintf(q{     syslog="%s"}, ($self->use_syslog  ? "on" : "off"));
    push @xmlstr, sprintf(q{     filter="%s"}, $self->filter_string) 
	if ($self->filter_string);
    push @xmlstr, sprintf(q{     >%s</path>}, $self->watch_path);
    push @xmlstr, sprintf(q{    <path type="exception">%s</path>}, $self->exception)
	if($self->exception);
    push @xmlstr, sprintf(q{    <path type="regexception">%s</path>}, $self->exception_regexp)
	if($self->exception_regexp);
    push @xmlstr, sprintf(q{  </watchlist>});
    push @xmlstr, sprintf(q{</config>});

    my $xmlstr = do { local $" = "\n"; "@xmlstr"; };
    print "XMLstr: \n$xmlstr\n" if $VERBOSE > 0;
    return $xmlstr;
}

sub _spawn_child {
    my $cmd = shift;
    my $pid;
    my $sigset  = POSIX::SigSet->new(&POSIX::SIGINT);
    $sigset->addset(&POSIX::SIGHUP);
    my $sigset2 = POSIX::SigSet->new(&POSIX::SIGHUP);

    # block 'INT' signal during fork
    sigprocmask(SIG_BLOCK, $sigset) or die "Can't block SIGINT for fork: $!\n";
    die "fork failed: $!" unless defined($pid = fork);
    sigprocmask(SIG_UNBLOCK, $sigset)
	or die "Can't unblock SIGINT for fork: $!\n";

    if ($pid) {
###########################################################################################
        # Parent process code executes from here
        # Parent records the child's birth and returns.
###########################################################################################
        $CHILDREN_G{$pid} = 1;
        $CHILDREN_G++;

        return;
    } else {
###########################################################################################
        # Child process code executes from here
###########################################################################################

        $SIG{INT} = 'DEFAULT';
        $SIG{HUP} =
	    sub { print STDERR "Received SIGHUP, child $$ resigning\n"; exit; };

	sigprocmask(SIG_BLOCK, $sigset2)
	    or die "Can't block SIGHUP while running command: $!\n";
	my $sigset_CHLD = POSIX::SigSet->new(&POSIX::SIGCHLD);
	sigprocmask(SIG_BLOCK, $sigset_CHLD)
	    or die "Can't block SIGCHLD while running command: $!\n";

	open(my $fh, '-|', $cmd);
	while (<$fh>) {
	    chomp;
	    warn "[result] $_\n";
	}
	close $fh;

	sigprocmask(SIG_UNBLOCK, $sigset_CHLD)
	    or die "Can't unblock SIGCHLD after command: $!\n";
	sigprocmask(SIG_UNBLOCK, $sigset2)
	    or die "Can't unblock SIGHUP after command: $!\n";

	exit 0;
    }
###########################################################################################
    ## End of _spawn_child
###########################################################################################
}

sub usage {
    return sub {
	$0 =~ m/^(.+)$/;
	my $script = $1;
	exec 'perldoc', '-t', $script;
    }
}
sub script_version {
    return sub {
	print "$PROGRAM $VERSION, a realtime filesystem monitor.\n";
	print "Cahya Wirawan <cahya at gmx dot at>, Vienna 2006.\n";
	exit 0;
    };
}

exit ( __PACKAGE__->main( @ARGV ) ) unless caller();

1;

=pod

=head1 NAME

iwatch - A realtime filesystem monitor

=head1 DESCRIPTION

A realtime filesystem monitor with the ability to filter, notify and execute based
on filesystem events that are received.

=head1 SYNOPSIS

 iwatch -f iwatch.xml /path/to/monitor

=head1 USAGE DAEMON

 iwatch [options] 

 iwatch [-d] [-f <config file>] [-v] [-p <pid file>]

Where options and [defaults] are:

In the daemon mode, iwatch has following options:

  -d Execute the application as daemon.
  -f <config file>
     Specify an alternate xml configuration file.
  -p <pid file>
     Specify an alternate pid file (default: $PIDFILE_G)
  -v Verbose mode.

=head1 USAGE INTERACTIVE

 iwatch [options]

 iwatch [-c command] [-C charset] [-e event[,event[,..]]] [-h|--help] [-m <email address>] 
         [-r] [-s <on|off>] [-t <filter string>] [-v] [--version] [-x exception]
         [-X <regex string as exception>] <target>

Where options and [defaults] are:

  Target is the directory or file you want to monitor.
  -c command
     Specify a command to be executed if an event occurs. And you can use
     following special string format in the command:
       %c Event cookie number
       %e Event name
       %f Full path of the filename that gets an event.
       %F The old filename in case moved_to event.
       %p Program name (iWatch)
       %v Version number
  -C charset
     Specify the charset (default is utf-8)
  -e event[,event[,..]]
     Specify a list of events you want to watch. Following are the possible events you can use:
       access        : file was accessed
       modify        : file was modified
       attrib        : file attributes changed
       close_write   : file closed, after being opened in writeable mode
       close_nowrite : file closed, after being opened in read-only mode
       close         : file closed, regardless of read/write mode
       open          : file was opened
       moved_from    : File was moved away from.
       moved_to      : File was moved to.
       move          : a file/dir within watched directory was moved
       create        : a file was created within watched directory
       delete        : a file was deleted within watched directory
       delete_self   : the watched file was deleted
       unmount       : file system on which watched file exists was unmounted
       q_overflow    : Event queued overflowed
       ignored       : File was ignored
       isdir         : event occurred against dir
       oneshot       : only send event once
       all_events    : All events
       default       : close_write, create, delete, move, delete_self and move_self.
  -h, --help
     Print this help.
  -m <email address>
     Specify the contact point's email address.
  -r Recursivity of the watched directory.
  -s <on|off>
     Enable or disable reports to the syslog (default is off/disabled)
  -t <filter string>
     Specify a filter string (regex) to compare with the filename or directory name. 
  -v verbose mode.
  --version
     Print the version number.
  -x exception
     Specify the file or directory which should not be watched.
  -X <regex string as exception>
     Specify a regex string as exception

=cut

__DATA__
